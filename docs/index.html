<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueSpiFlashRK: PublishQueueSpiFlashRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PublishQueueSpiFlashRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a> <em>Particle offline event queue storage on external SPI flash chips</em></p>
<p><b>Typical uses case:</b> When you have a large number of events you want to store offline and you have an external SPI NOR flash chip available in your design.</p>
<p>This library is designed to hold a circular buffer of events in a FIFO queue stored in SPI NOR flash memory. It can only be used with external SPI flash chips; it cannot be used with the built-in SPI flash on Particle Gen 3 and Gen 4 devices. It cannot be used with SD cards.</p>
<p>The main advantage of this library is that it does not require a file system, like LittleFS or SPIFFS. It takes advantage of the natural circularity of the buffer to wear level across all sectors. It works up to the maximum event size and can pack multiple events into a single sector for efficiency.</p>
<p>It also is highly reliable: All events are written to flash before attempting to send, so if the device is reset the events will be safely stored. The format of the flash is designed to be resilient in the case of unexpected resets, even while writing.</p>
<p>It limited to 16-bit sector numbers within the circular buffer, so the maximum size circular buffer is 256 Mbyte but the chip can be larger than that.</p>
<h1>SPI flash</h1>
<p>It works with SPI flash chips that are compatible with <a href="https://github.com/rickkas7/SpiFlashRK">SpiFlashRK</a> including most from Winbond, Macronix, and ISSI. It supports all sizes of devices, including those that require 4-byte addressing (larger than 16 Mbyte). It requires 4096 byte sectors, however.</p>
<p>It can use any portion, divided at a sector boundary, or the entire chip.</p>
<p>A chip can contain multiple separate buffers if desired by instantiating multiple CircularBuffer SpiFlashRK objects sharing a single SpiFlash object. You can also use other portions of the flash for other purposes as long as the other uses properly lock the SPI bus or access it using the shared SpiFlash object.</p>
<p>It can also be used with most other vendors of SPI NOR flash chip by creating an adapter subclass, which can be done from your code without modifying SpIFlashRK. Note that it cannot be used with NAND flash chips that are commonly used with SD cards.</p>
<h1>Example</h1>
<p>See the example 1-simple for using this library.</p>
<h2>Create a SpiFlash object for your chip</h2>
<p>You will typically create a global object for your SPI flash chip by using one of the following lines, possibly with a different CS pin:</p>
<div class="fragment"><div class="line"><span class="comment">// Pick a chip, port, and CS line</span></div>
<div class="line"><span class="comment">// SpiFlashISSI spiFlash(SPI, A2);</span></div>
<div class="line"><span class="comment">// SpiFlashWinbond spiFlash(SPI, A4);</span></div>
<div class="line">SpiFlashMacronix spiFlash(SPI, A4);</div>
<div class="line"><span class="comment">// SpiFlashWinbond spiFlash(SPI1, D5);</span></div>
</div><!-- fragment --><h2>setup</h2>
<p>From setup, you need to call <code>spiFlash.begin()</code> and initialize the <code>PublishQueueSpiFlash</code> object:</p>
<div class="fragment"><div class="line">spiFlash.begin();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a70499fc10fbb59a9522fc6e763d7cbfc">PublishQueueSpiFlashRK::instance</a>()</div>
<div class="line">    .<a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#ae2a23fcaed89654f9c9f17adfdddb4bd">withSpiFlash</a>(&amp;spiFlash, 0, 100 * 4096)</div>
<div class="line">    .<a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a70e5c4ec556be575b3cba06af692dbf3">setup</a>();</div>
<div class="ttc" id="aclass_publish_queue_spi_flash_r_k_html_a70499fc10fbb59a9522fc6e763d7cbfc"><div class="ttname"><a href="class_publish_queue_spi_flash_r_k.html#a70499fc10fbb59a9522fc6e763d7cbfc">PublishQueueSpiFlashRK::instance</a></div><div class="ttdeci">static PublishQueueSpiFlashRK &amp; instance()</div><div class="ttdoc">Gets the singleton instance of this class, allocating it if necessary.</div><div class="ttdef"><b>Definition</b> PublishQueueSpiFlashRK.cpp:9</div></div>
<div class="ttc" id="aclass_publish_queue_spi_flash_r_k_html_a70e5c4ec556be575b3cba06af692dbf3"><div class="ttname"><a href="class_publish_queue_spi_flash_r_k.html#a70e5c4ec556be575b3cba06af692dbf3">PublishQueueSpiFlashRK::setup</a></div><div class="ttdeci">bool setup()</div><div class="ttdoc">Perform setup operations; call this from global application setup()</div><div class="ttdef"><b>Definition</b> PublishQueueSpiFlashRK.cpp:30</div></div>
<div class="ttc" id="aclass_publish_queue_spi_flash_r_k_html_ae2a23fcaed89654f9c9f17adfdddb4bd"><div class="ttname"><a href="class_publish_queue_spi_flash_r_k.html#ae2a23fcaed89654f9c9f17adfdddb4bd">PublishQueueSpiFlashRK::withSpiFlash</a></div><div class="ttdeci">PublishQueueSpiFlashRK &amp; withSpiFlash(SpiFlash *spiFlash, size_t addrStart, size_t addrEnd)</div><div class="ttdef"><b>Definition</b> PublishQueueSpiFlashRK.cpp:22</div></div>
</div><!-- fragment --><p>Note the <code>withSpiFlash</code> call; you use this to specify the <code>SpiFlash</code> object for your chip, and also the start and end addresses to use for your chip. The parameters are:</p>
<ul>
<li>spiFlash The SpiFlashRK object for the SPI NOR flash chip.</li>
<li>addrStart Address to start at (typically 0). Must be sector aligned (multiple of 4096 bytes).</li>
<li>addrEnd Address to end at (not inclusive). Must be sector aligned (multiple of 4096 bytes).</li>
</ul>
<h2>loop</h2>
<p>From loop(), make sure you call this, or publishing will not occur:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a70499fc10fbb59a9522fc6e763d7cbfc">PublishQueueSpiFlashRK::instance</a>().<a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a185eb2c005cd2cd0c05580637a2a61e9">loop</a>();</div>
<div class="ttc" id="aclass_publish_queue_spi_flash_r_k_html_a185eb2c005cd2cd0c05580637a2a61e9"><div class="ttname"><a href="class_publish_queue_spi_flash_r_k.html#a185eb2c005cd2cd0c05580637a2a61e9">PublishQueueSpiFlashRK::loop</a></div><div class="ttdeci">void loop()</div><div class="ttdoc">Perform application loop operations; call this from global application loop()</div><div class="ttdef"><b>Definition</b> PublishQueueSpiFlashRK.cpp:63</div></div>
</div><!-- fragment --><p>While the actual publish occurs in its own thread, the processing of the queue only occurs from the loop thread when this is called.</p>
<h2>publish</h2>
<p>Instead of using <code>Particle.publish()</code> you use code that looks like this:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a70499fc10fbb59a9522fc6e763d7cbfc">PublishQueueSpiFlashRK::instance</a>().<a class="code hl_function" href="class_publish_queue_spi_flash_r_k.html#a5f5027d4b64d1bc21254fbaa0733e807">publish</a>(<span class="stringliteral">&quot;testEvent&quot;</span>, buf, WITH_ACK);</div>
<div class="ttc" id="aclass_publish_queue_spi_flash_r_k_html_a5f5027d4b64d1bc21254fbaa0733e807"><div class="ttname"><a href="class_publish_queue_spi_flash_r_k.html#a5f5027d4b64d1bc21254fbaa0733e807">PublishQueueSpiFlashRK::publish</a></div><div class="ttdeci">bool publish(const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</div><div class="ttdoc">Overload for publishing an event.</div><div class="ttdef"><b>Definition</b> PublishQueueSpiFlashRK.h:89</div></div>
</div><!-- fragment --><p>You can call this whether online or offline, and the event will be queued for sending later. It does not block, other than if the SPI flash is currently in use.</p>
<h1>Additional resources</h1>
<ul>
<li><a href="https://github.com/rickkas7/CircularBufferSpiFlashRK">CircularBufferSpiFlashRK</a> - the library that manages the circular buffer on the flash chip</li>
<li><a href="https://github.com/rickkas7/SpiFlashRK">SpiFlashRK</a>] - the library that manages the SPI flash chip</li>
<li><a href="https://github.com/rickkas7/BackgroundPublishRK">BackgroundPublishRK</a> - class for publishing in the background</li>
<li><a href="https://github.com/rickkas7/PublishQueuePosixRK">PublishQueuePosixRK</a> - alternative to this library that stores events on the built-in flash file system on Particle Gen 3 and Gen 4 devices.</li>
</ul>
<h1>Version history</h1>
<h2>0.0.1 (2024-07-26)</h2>
<p>Initial version. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
