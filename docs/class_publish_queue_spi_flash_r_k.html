<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueSpiFlashRK: PublishQueueSpiFlashRK Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PublishQueueSpiFlashRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">PublishQueueSpiFlashRK Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_publish_queue_spi_flash_r_k_8h_source.html">PublishQueueSpiFlashRK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2a23fcaed89654f9c9f17adfdddb4bd" id="r_ae2a23fcaed89654f9c9f17adfdddb4bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a23fcaed89654f9c9f17adfdddb4bd">withSpiFlash</a> (SpiFlash *<a class="el" href="#a1da50a10a396fe0709ac9a1c8738b75c">spiFlash</a>, size_t <a class="el" href="#aca5f3d43bdc8c8902ffe22a9de6f5f8a">addrStart</a>, size_t <a class="el" href="#af8e9a8704892e4943b1ac6f4f2515724">addrEnd</a>)</td></tr>
<tr class="separator:ae2a23fcaed89654f9c9f17adfdddb4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae634e2686cc1bf177ae55ebc627ac592" id="r_ae634e2686cc1bf177ae55ebc627ac592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae634e2686cc1bf177ae55ebc627ac592">withPublishCompleteUserCallback</a> (std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&gt; cb)</td></tr>
<tr class="memdesc:ae634e2686cc1bf177ae55ebc627ac592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function to call with publish is complete.  <br /></td></tr>
<tr class="separator:ae634e2686cc1bf177ae55ebc627ac592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e5c4ec556be575b3cba06af692dbf3" id="r_a70e5c4ec556be575b3cba06af692dbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3">setup</a> ()</td></tr>
<tr class="memdesc:a70e5c4ec556be575b3cba06af692dbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform setup operations; call this from global application <a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a>  <br /></td></tr>
<tr class="separator:a70e5c4ec556be575b3cba06af692dbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185eb2c005cd2cd0c05580637a2a61e9" id="r_a185eb2c005cd2cd0c05580637a2a61e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a185eb2c005cd2cd0c05580637a2a61e9">loop</a> ()</td></tr>
<tr class="memdesc:a185eb2c005cd2cd0c05580637a2a61e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform application loop operations; call this from global application <a class="el" href="#a185eb2c005cd2cd0c05580637a2a61e9" title="Perform application loop operations; call this from global application loop()">loop()</a>  <br /></td></tr>
<tr class="separator:a185eb2c005cd2cd0c05580637a2a61e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5027d4b64d1bc21254fbaa0733e807" id="r_a5f5027d4b64d1bc21254fbaa0733e807"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f5027d4b64d1bc21254fbaa0733e807">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a5f5027d4b64d1bc21254fbaa0733e807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a5f5027d4b64d1bc21254fbaa0733e807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf26a1fb98784d638860667d6791801" id="r_afbf26a1fb98784d638860667d6791801"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf26a1fb98784d638860667d6791801">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:afbf26a1fb98784d638860667d6791801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:afbf26a1fb98784d638860667d6791801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e685ec23821dab6063e50a00225e91" id="r_a48e685ec23821dab6063e50a00225e91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48e685ec23821dab6063e50a00225e91">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a48e685ec23821dab6063e50a00225e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a48e685ec23821dab6063e50a00225e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dd0a57845fc7e06dd9f5209de05165" id="r_a14dd0a57845fc7e06dd9f5209de05165"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14dd0a57845fc7e06dd9f5209de05165">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a14dd0a57845fc7e06dd9f5209de05165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.  <br /></td></tr>
<tr class="separator:a14dd0a57845fc7e06dd9f5209de05165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bca2f5a96ff2ef760b9c963536767d" id="r_a43bca2f5a96ff2ef760b9c963536767d"><td class="memItemLeft" align="right" valign="top"><a id="a43bca2f5a96ff2ef760b9c963536767d" name="a43bca2f5a96ff2ef760b9c963536767d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQueues</b> ()</td></tr>
<tr class="memdesc:a43bca2f5a96ff2ef760b9c963536767d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty both the RAM and file based queues. Any queued events are discarded. <br /></td></tr>
<tr class="separator:a43bca2f5a96ff2ef760b9c963536767d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c00cca104d10541f1d78d259013704" id="r_a33c00cca104d10541f1d78d259013704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33c00cca104d10541f1d78d259013704">setPausePublishing</a> (bool value)</td></tr>
<tr class="memdesc:a33c00cca104d10541f1d78d259013704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume publishing events.  <br /></td></tr>
<tr class="separator:a33c00cca104d10541f1d78d259013704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec8fdac401f23df1070de1b9ee7bcee" id="r_abec8fdac401f23df1070de1b9ee7bcee"><td class="memItemLeft" align="right" valign="top"><a id="abec8fdac401f23df1070de1b9ee7bcee" name="abec8fdac401f23df1070de1b9ee7bcee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPausePublishing</b> () const</td></tr>
<tr class="memdesc:abec8fdac401f23df1070de1b9ee7bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the pause publishing flag. <br /></td></tr>
<tr class="separator:abec8fdac401f23df1070de1b9ee7bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887cab36de8ebb85b1240308598b747d" id="r_a887cab36de8ebb85b1240308598b747d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887cab36de8ebb85b1240308598b747d">getCanSleep</a> () const</td></tr>
<tr class="memdesc:a887cab36de8ebb85b1240308598b747d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if it's a good time to go to sleep.  <br /></td></tr>
<tr class="separator:a887cab36de8ebb85b1240308598b747d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dce18015364d4eb0ffe38c9a43b514" id="r_a06dce18015364d4eb0ffe38c9a43b514"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06dce18015364d4eb0ffe38c9a43b514">getNumEvents</a> ()</td></tr>
<tr class="memdesc:a06dce18015364d4eb0ffe38c9a43b514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of events queued.  <br /></td></tr>
<tr class="separator:a06dce18015364d4eb0ffe38c9a43b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07086fd99709b0540e0bf267a841f18" id="r_aa07086fd99709b0540e0bf267a841f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa07086fd99709b0540e0bf267a841f18">lock</a> ()</td></tr>
<tr class="memdesc:aa07086fd99709b0540e0bf267a841f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex that protects shared resources.  <br /></td></tr>
<tr class="separator:aa07086fd99709b0540e0bf267a841f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc639a58e593645dfa9403aa6cfbbc5" id="r_a7dc639a58e593645dfa9403aa6cfbbc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc639a58e593645dfa9403aa6cfbbc5">tryLock</a> ()</td></tr>
<tr class="memdesc:a7dc639a58e593645dfa9403aa6cfbbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to lock the mutex that protects shared resources.  <br /></td></tr>
<tr class="separator:a7dc639a58e593645dfa9403aa6cfbbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f95e3ccf5a72e2f51169181df5abfd0" id="r_a5f95e3ccf5a72e2f51169181df5abfd0"><td class="memItemLeft" align="right" valign="top"><a id="a5f95e3ccf5a72e2f51169181df5abfd0" name="a5f95e3ccf5a72e2f51169181df5abfd0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr class="memdesc:a5f95e3ccf5a72e2f51169181df5abfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex that protects shared resources. <br /></td></tr>
<tr class="separator:a5f95e3ccf5a72e2f51169181df5abfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a70499fc10fbb59a9522fc6e763d7cbfc" id="r_a70499fc10fbb59a9522fc6e763d7cbfc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc">instance</a> ()</td></tr>
<tr class="memdesc:a70499fc10fbb59a9522fc6e763d7cbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the singleton instance of this class, allocating it if necessary.  <br /></td></tr>
<tr class="separator:a70499fc10fbb59a9522fc6e763d7cbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a927d51f0ac9914db905c82585a701a" id="r_a5a927d51f0ac9914db905c82585a701a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a927d51f0ac9914db905c82585a701a">PublishQueueSpiFlashRK</a> ()</td></tr>
<tr class="memdesc:a5a927d51f0ac9914db905c82585a701a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor is protected because the class is a singleton.  <br /></td></tr>
<tr class="separator:a5a927d51f0ac9914db905c82585a701a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0c3c812ba7373499463b5f043241b" id="r_ad1b0c3c812ba7373499463b5f043241b"><td class="memItemLeft" align="right" valign="top"><a id="ad1b0c3c812ba7373499463b5f043241b" name="ad1b0c3c812ba7373499463b5f043241b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PublishQueueSpiFlashRK</b> ()</td></tr>
<tr class="memdesc:ad1b0c3c812ba7373499463b5f043241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor is protected because the class is a singleton and cannot be deleted. <br /></td></tr>
<tr class="separator:ad1b0c3c812ba7373499463b5f043241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596a2486c5a87a5fabec9f06aa577e98" id="r_a596a2486c5a87a5fabec9f06aa577e98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596a2486c5a87a5fabec9f06aa577e98">PublishQueueSpiFlashRK</a> (const <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;)=delete</td></tr>
<tr class="separator:a596a2486c5a87a5fabec9f06aa577e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddb90f3d1fb93999c8b7fbf1a11d8f4" id="r_a2ddb90f3d1fb93999c8b7fbf1a11d8f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ddb90f3d1fb93999c8b7fbf1a11d8f4">operator=</a> (const <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;)=delete</td></tr>
<tr class="separator:a2ddb90f3d1fb93999c8b7fbf1a11d8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5968e5eb7c4e7873a31a9974c717fb19" id="r_a5968e5eb7c4e7873a31a9974c717fb19"><td class="memItemLeft" align="right" valign="top"><a id="a5968e5eb7c4e7873a31a9974c717fb19" name="a5968e5eb7c4e7873a31a9974c717fb19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>publishCompleteCallback</b> (bool succeeded, const char *eventName, const char *eventData)</td></tr>
<tr class="memdesc:a5968e5eb7c4e7873a31a9974c717fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for BackgroundPublishRK library. <br /></td></tr>
<tr class="separator:a5968e5eb7c4e7873a31a9974c717fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159e5045592926df630f2b12f355565b" id="r_a159e5045592926df630f2b12f355565b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159e5045592926df630f2b12f355565b">stateConnectWait</a> ()</td></tr>
<tr class="memdesc:a159e5045592926df630f2b12f355565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting to connect to the Particle cloud.  <br /></td></tr>
<tr class="separator:a159e5045592926df630f2b12f355565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6922a70eaf3b09a1e193328ad88d08d6" id="r_a6922a70eaf3b09a1e193328ad88d08d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6922a70eaf3b09a1e193328ad88d08d6">stateWait</a> ()</td></tr>
<tr class="memdesc:a6922a70eaf3b09a1e193328ad88d08d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting to publish.  <br /></td></tr>
<tr class="separator:a6922a70eaf3b09a1e193328ad88d08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc6db6a92789acb01f9eac143ca6cb" id="r_a13fc6db6a92789acb01f9eac143ca6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13fc6db6a92789acb01f9eac143ca6cb">statePublishWait</a> ()</td></tr>
<tr class="memdesc:a13fc6db6a92789acb01f9eac143ca6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting for publish to complete.  <br /></td></tr>
<tr class="separator:a13fc6db6a92789acb01f9eac143ca6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a39d928073232f6bf5be2d3d24c5b953c" id="r_a39d928073232f6bf5be2d3d24c5b953c"><td class="memItemLeft" align="right" valign="top"><a id="a39d928073232f6bf5be2d3d24c5b953c" name="a39d928073232f6bf5be2d3d24c5b953c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>systemEventHandler</b> (system_event_t event, int param)</td></tr>
<tr class="memdesc:a39d928073232f6bf5be2d3d24c5b953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">system event handler, used to detect reset events <br /></td></tr>
<tr class="separator:a39d928073232f6bf5be2d3d24c5b953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0d16202be4f2089df5ad4b256824360b" id="r_a0d16202be4f2089df5ad4b256824360b"><td class="memItemLeft" align="right" valign="top">os_mutex_recursive_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d16202be4f2089df5ad4b256824360b">mutex</a> = 0</td></tr>
<tr class="memdesc:a0d16202be4f2089df5ad4b256824360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect shared resources.  <br /></td></tr>
<tr class="separator:a0d16202be4f2089df5ad4b256824360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da50a10a396fe0709ac9a1c8738b75c" id="r_a1da50a10a396fe0709ac9a1c8738b75c"><td class="memItemLeft" align="right" valign="top"><a id="a1da50a10a396fe0709ac9a1c8738b75c" name="a1da50a10a396fe0709ac9a1c8738b75c"></a>
SpiFlash *&#160;</td><td class="memItemRight" valign="bottom"><b>spiFlash</b> = nullptr</td></tr>
<tr class="memdesc:a1da50a10a396fe0709ac9a1c8738b75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SpiFlash object to interface with the flash chip. <br /></td></tr>
<tr class="separator:a1da50a10a396fe0709ac9a1c8738b75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5f3d43bdc8c8902ffe22a9de6f5f8a" id="r_aca5f3d43bdc8c8902ffe22a9de6f5f8a"><td class="memItemLeft" align="right" valign="top"><a id="aca5f3d43bdc8c8902ffe22a9de6f5f8a" name="aca5f3d43bdc8c8902ffe22a9de6f5f8a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>addrStart</b> = 0</td></tr>
<tr class="memdesc:aca5f3d43bdc8c8902ffe22a9de6f5f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address to start in the chip, must be sector aligned. <br /></td></tr>
<tr class="separator:aca5f3d43bdc8c8902ffe22a9de6f5f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9a8704892e4943b1ac6f4f2515724" id="r_af8e9a8704892e4943b1ac6f4f2515724"><td class="memItemLeft" align="right" valign="top"><a id="af8e9a8704892e4943b1ac6f4f2515724" name="af8e9a8704892e4943b1ac6f4f2515724"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>addrEnd</b> = 0</td></tr>
<tr class="memdesc:af8e9a8704892e4943b1ac6f4f2515724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address to end in the chip (exclusive), must be sector aligned. <br /></td></tr>
<tr class="separator:af8e9a8704892e4943b1ac6f4f2515724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341306c38335d0d9a3aba1163cf3653f" id="r_a341306c38335d0d9a3aba1163cf3653f"><td class="memItemLeft" align="right" valign="top"><a id="a341306c38335d0d9a3aba1163cf3653f" name="a341306c38335d0d9a3aba1163cf3653f"></a>
CircularBufferSpiFlashRK *&#160;</td><td class="memItemRight" valign="bottom"><b>circBuffer</b> = nullptr</td></tr>
<tr class="memdesc:a341306c38335d0d9a3aba1163cf3653f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to manage the circular buffer. <br /></td></tr>
<tr class="separator:a341306c38335d0d9a3aba1163cf3653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5b25824bca8a1611c6f761729dd46a" id="r_afc5b25824bca8a1611c6f761729dd46a"><td class="memItemLeft" align="right" valign="top"><a id="afc5b25824bca8a1611c6f761729dd46a" name="afc5b25824bca8a1611c6f761729dd46a"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>stateTime</b> = 0</td></tr>
<tr class="memdesc:afc5b25824bca8a1611c6f761729dd46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">millis() value when entering the state, used for stateWait <br /></td></tr>
<tr class="separator:afc5b25824bca8a1611c6f761729dd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf1cfde0316f3a2383c817f5e15bc82" id="r_a2bf1cfde0316f3a2383c817f5e15bc82"><td class="memItemLeft" align="right" valign="top"><a id="a2bf1cfde0316f3a2383c817f5e15bc82" name="a2bf1cfde0316f3a2383c817f5e15bc82"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>durationMs</b> = 0</td></tr>
<tr class="memdesc:a2bf1cfde0316f3a2383c817f5e15bc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait before publishing in milliseconds, used in stateWait <br /></td></tr>
<tr class="separator:a2bf1cfde0316f3a2383c817f5e15bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4718b4637e353f7d172942417e8d780" id="r_ac4718b4637e353f7d172942417e8d780"><td class="memItemLeft" align="right" valign="top"><a id="ac4718b4637e353f7d172942417e8d780" name="ac4718b4637e353f7d172942417e8d780"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>publishComplete</b> = false</td></tr>
<tr class="memdesc:ac4718b4637e353f7d172942417e8d780"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the publish has completed (successfully or not) <br /></td></tr>
<tr class="separator:ac4718b4637e353f7d172942417e8d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bddb302e7098a07427db5134646318" id="r_a12bddb302e7098a07427db5134646318"><td class="memItemLeft" align="right" valign="top"><a id="a12bddb302e7098a07427db5134646318" name="a12bddb302e7098a07427db5134646318"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>publishSuccess</b> = false</td></tr>
<tr class="memdesc:a12bddb302e7098a07427db5134646318"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the publish succeeded <br /></td></tr>
<tr class="separator:a12bddb302e7098a07427db5134646318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d53af680731e85beec6c61b87418f8" id="r_ae5d53af680731e85beec6c61b87418f8"><td class="memItemLeft" align="right" valign="top"><a id="ae5d53af680731e85beec6c61b87418f8" name="ae5d53af680731e85beec6c61b87418f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pausePublishing</b> = false</td></tr>
<tr class="memdesc:ae5d53af680731e85beec6c61b87418f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to pause publishing (used from automated test) <br /></td></tr>
<tr class="separator:ae5d53af680731e85beec6c61b87418f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba138268498227a7912ca0a080d14c3a" id="r_aba138268498227a7912ca0a080d14c3a"><td class="memItemLeft" align="right" valign="top"><a id="aba138268498227a7912ca0a080d14c3a" name="aba138268498227a7912ca0a080d14c3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSleep</b> = false</td></tr>
<tr class="memdesc:aba138268498227a7912ca0a080d14c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if this is a good time to go to sleep <br /></td></tr>
<tr class="separator:aba138268498227a7912ca0a080d14c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd4a7dd9ede7360fe3b6dea76d3219a" id="r_a1fd4a7dd9ede7360fe3b6dea76d3219a"><td class="memItemLeft" align="right" valign="top"><a id="a1fd4a7dd9ede7360fe3b6dea76d3219a" name="a1fd4a7dd9ede7360fe3b6dea76d3219a"></a>
CircularBufferSpiFlashRK::ReadInfo&#160;</td><td class="memItemRight" valign="bottom"><b>curEvent</b></td></tr>
<tr class="memdesc:a1fd4a7dd9ede7360fe3b6dea76d3219a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event that is currently being processed. <br /></td></tr>
<tr class="separator:a1fd4a7dd9ede7360fe3b6dea76d3219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d041da8ea88d2ecd8134d2f5f04fe59" id="r_a3d041da8ea88d2ecd8134d2f5f04fe59"><td class="memItemLeft" align="right" valign="top"><a id="a3d041da8ea88d2ecd8134d2f5f04fe59" name="a3d041da8ea88d2ecd8134d2f5f04fe59"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterConnect</b> = 2000</td></tr>
<tr class="memdesc:a3d041da8ea88d2ecd8134d2f5f04fe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">time to wait after Particle.connected() before publishing <br /></td></tr>
<tr class="separator:a3d041da8ea88d2ecd8134d2f5f04fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd19c97e21b6ec3d28778a401d07e7b" id="r_a7bd19c97e21b6ec3d28778a401d07e7b"><td class="memItemLeft" align="right" valign="top"><a id="a7bd19c97e21b6ec3d28778a401d07e7b" name="a7bd19c97e21b6ec3d28778a401d07e7b"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitBetweenPublish</b> = 1000</td></tr>
<tr class="memdesc:a7bd19c97e21b6ec3d28778a401d07e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait in milliseconds between publishes <br /></td></tr>
<tr class="separator:a7bd19c97e21b6ec3d28778a401d07e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1cf5063f3f7582bc6870b18add0d65" id="r_a9b1cf5063f3f7582bc6870b18add0d65"><td class="memItemLeft" align="right" valign="top"><a id="a9b1cf5063f3f7582bc6870b18add0d65" name="a9b1cf5063f3f7582bc6870b18add0d65"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterFailure</b> = 30000</td></tr>
<tr class="memdesc:a9b1cf5063f3f7582bc6870b18add0d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait after failing to publish before trying again <br /></td></tr>
<tr class="separator:a9b1cf5063f3f7582bc6870b18add0d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b6083e00cb7e2259f9867f72d01535" id="r_ab0b6083e00cb7e2259f9867f72d01535"><td class="memItemLeft" align="right" valign="top"><a id="ab0b6083e00cb7e2259f9867f72d01535" name="ab0b6083e00cb7e2259f9867f72d01535"></a>
std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&#160;</td><td class="memItemRight" valign="bottom"><b>publishCompleteUserCallback</b> ) = 0</td></tr>
<tr class="memdesc:ab0b6083e00cb7e2259f9867f72d01535"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback for publish complete. <br /></td></tr>
<tr class="separator:ab0b6083e00cb7e2259f9867f72d01535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a99ad98242cff1425efdb51634946" id="r_a433a99ad98242cff1425efdb51634946"><td class="memItemLeft" align="right" valign="top"><a id="a433a99ad98242cff1425efdb51634946" name="a433a99ad98242cff1425efdb51634946"></a>
std::function&lt; void(<a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;)&#160;</td><td class="memItemRight" valign="bottom"><b>stateHandler</b> ) = 0</td></tr>
<tr class="memdesc:a433a99ad98242cff1425efdb51634946"><td class="mdescLeft">&#160;</td><td class="mdescRight">state handler (stateConnectWait, stateWait, etc). <br /></td></tr>
<tr class="separator:a433a99ad98242cff1425efdb51634946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa1882834270be9a7d25f4524618dc6ea" id="r_aa1882834270be9a7d25f4524618dc6ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1882834270be9a7d25f4524618dc6ea">_instance</a></td></tr>
<tr class="memdesc:aa1882834270be9a7d25f4524618dc6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton instance of this class.  <br /></td></tr>
<tr class="separator:aa1882834270be9a7d25f4524618dc6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a singleton; you do not create one as a global, on the stack, or with new.</p>
<p>From global application setup you must call: <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a>.<a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a>;</p>
<p>From global application loop you must call: <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a>.<a class="el" href="#a185eb2c005cd2cd0c05580637a2a61e9" title="Perform application loop operations; call this from global application loop()">loop()</a>; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a927d51f0ac9914db905c82585a701a" name="a5a927d51f0ac9914db905c82585a701a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a927d51f0ac9914db905c82585a701a">&#9670;&#160;</a></span>PublishQueueSpiFlashRK() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueSpiFlashRK::PublishQueueSpiFlashRK </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor is protected because the class is a singleton. </p>
<p>Use <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a> to instantiate the singleton. </p>

</div>
</div>
<a id="a596a2486c5a87a5fabec9f06aa577e98" name="a596a2486c5a87a5fabec9f06aa577e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596a2486c5a87a5fabec9f06aa577e98">&#9670;&#160;</a></span>PublishQueueSpiFlashRK() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueSpiFlashRK::PublishQueueSpiFlashRK </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This class is a singleton and cannot be copied </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a887cab36de8ebb85b1240308598b747d" name="a887cab36de8ebb85b1240308598b747d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887cab36de8ebb85b1240308598b747d">&#9670;&#160;</a></span>getCanSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::getCanSleep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if it's a good time to go to sleep. </p>
<p>If a publish is not in progress and the queue is empty, returns true.</p>
<p>If pausePublishing is true, then return true if either the current publish has completed, or not cloud connected. </p>

</div>
</div>
<a id="a06dce18015364d4eb0ffe38c9a43b514" name="a06dce18015364d4eb0ffe38c9a43b514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06dce18015364d4eb0ffe38c9a43b514">&#9670;&#160;</a></span>getNumEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueueSpiFlashRK::getNumEvents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of events queued. </p>
<p>This is the number of events in the RAM-based queue and the file-based queue. This operation is fast; the file queue length is stored in RAM, so this command does not need to access the file system.</p>
<p>If an event is currently being sent, the result includes this event. </p>

</div>
</div>
<a id="a70499fc10fbb59a9522fc6e763d7cbfc" name="a70499fc10fbb59a9522fc6e763d7cbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70499fc10fbb59a9522fc6e763d7cbfc">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp; PublishQueueSpiFlashRK::instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the singleton instance of this class, allocating it if necessary. </p>
<p>Use <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a> to instantiate the singleton. </p>

</div>
</div>
<a id="aa07086fd99709b0540e0bf267a841f18" name="aa07086fd99709b0540e0bf267a841f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07086fd99709b0540e0bf267a841f18">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the mutex that protects shared resources. </p>
<p>This is compatible with <code>WITH_LOCK(*this)</code>.</p>
<p>The mutex is not recursive so do not lock it within a locked section. </p>

</div>
</div>
<a id="a185eb2c005cd2cd0c05580637a2a61e9" name="a185eb2c005cd2cd0c05580637a2a61e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185eb2c005cd2cd0c05580637a2a61e9">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform application loop operations; call this from global application <a class="el" href="#a185eb2c005cd2cd0c05580637a2a61e9" title="Perform application loop operations; call this from global application loop()">loop()</a> </p>
<p>You typically use <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a>.<a class="el" href="#a185eb2c005cd2cd0c05580637a2a61e9" title="Perform application loop operations; call this from global application loop()">loop()</a>; </p>

</div>
</div>
<a id="a2ddb90f3d1fb93999c8b7fbf1a11d8f4" name="a2ddb90f3d1fb93999c8b7fbf1a11d8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddb90f3d1fb93999c8b7fbf1a11d8f4">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp; PublishQueueSpiFlashRK::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This class is a singleton and cannot be copied </p>

</div>
</div>
<a id="a48e685ec23821dab6063e50a00225e91" name="a48e685ec23821dab6063e50a00225e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e685ec23821dab6063e50a00225e91">&#9670;&#160;</a></span>publish() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ttl</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags2</em><span class="paramdefsep"> = </span><span class="paramdefval">PublishFlags()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="afbf26a1fb98784d638860667d6791801" name="afbf26a1fb98784d638860667d6791801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf26a1fb98784d638860667d6791801">&#9670;&#160;</a></span>publish() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags2</em><span class="paramdefsep"> = </span><span class="paramdefval">PublishFlags()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a5f5027d4b64d1bc21254fbaa0733e807" name="a5f5027d4b64d1bc21254fbaa0733e807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5027d4b64d1bc21254fbaa0733e807">&#9670;&#160;</a></span>publish() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::publish </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags2</em><span class="paramdefsep"> = </span><span class="paramdefval">PublishFlags()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a14dd0a57845fc7e06dd9f5209de05165" name="a14dd0a57845fc7e06dd9f5209de05165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dd0a57845fc7e06dd9f5209de05165">&#9670;&#160;</a></span>publishCommon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::publishCommon </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>eventName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ttl</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags</td>          <td class="paramname"><span class="paramname"><em>flags2</em><span class="paramdefsep"> = </span><span class="paramdefval">PublishFlags()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a33c00cca104d10541f1d78d259013704" name="a33c00cca104d10541f1d78d259013704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c00cca104d10541f1d78d259013704">&#9670;&#160;</a></span>setPausePublishing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::setPausePublishing </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume publishing events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to set, true = pause, false = normal operation</td></tr>
  </table>
  </dd>
</dl>
<p>If called while a publish is in progress, that publish will still proceed, but the next event (if any) will not be attempted.</p>
<p>This is used by the automated test tool; you probably won't need to manually manage this under normal circumstances. </p>

</div>
</div>
<a id="a70e5c4ec556be575b3cba06af692dbf3" name="a70e5c4ec556be575b3cba06af692dbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e5c4ec556be575b3cba06af692dbf3">&#9670;&#160;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::setup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform setup operations; call this from global application <a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a> </p>
<p>You typically use <a class="el" href="#a70499fc10fbb59a9522fc6e763d7cbfc" title="Gets the singleton instance of this class, allocating it if necessary.">PublishQueueSpiFlashRK::instance()</a>.<a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a>; </p>

</div>
</div>
<a id="a159e5045592926df630f2b12f355565b" name="a159e5045592926df630f2b12f355565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159e5045592926df630f2b12f355565b">&#9670;&#160;</a></span>stateConnectWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::stateConnectWait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting to connect to the Particle cloud. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="a13fc6db6a92789acb01f9eac143ca6cb" name="a13fc6db6a92789acb01f9eac143ca6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fc6db6a92789acb01f9eac143ca6cb">&#9670;&#160;</a></span>statePublishWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::statePublishWait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting for publish to complete. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="a6922a70eaf3b09a1e193328ad88d08d6" name="a6922a70eaf3b09a1e193328ad88d08d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6922a70eaf3b09a1e193328ad88d08d6">&#9670;&#160;</a></span>stateWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueSpiFlashRK::stateWait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting to publish. </p>
<p>stateTime and durationMs determine whether to stay in this state waiting, or whether to publish and go into statePublishWait.</p>
<p>Next state: statePublishWait or stateConnectWait </p>

</div>
</div>
<a id="a7dc639a58e593645dfa9403aa6cfbbc5" name="a7dc639a58e593645dfa9403aa6cfbbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc639a58e593645dfa9403aa6cfbbc5">&#9670;&#160;</a></span>tryLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueSpiFlashRK::tryLock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to lock the mutex that protects shared resources. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was locked or false if it was busy already. </dd></dl>

</div>
</div>
<a id="ae634e2686cc1bf177ae55ebc627ac592" name="ae634e2686cc1bf177ae55ebc627ac592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae634e2686cc1bf177ae55ebc627ac592">&#9670;&#160;</a></span>withPublishCompleteUserCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp; PublishQueueSpiFlashRK::withPublishCompleteUserCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&gt;</td>          <td class="paramname"><span class="paramname"><em>cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback function to call with publish is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback function or C++ lambda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PublishQueuePosix&amp;</dd></dl>
<p>The callback has this prototype and can be a function or a C++11 lambda, which allows the callback to be a class method.</p>
<p>void callback(bool succeeded, const char *eventName, const char *eventData)</p>
<p>The parameters are:</p><ul>
<li>succeeded: true if the publish succeeded or false if faled</li>
<li>eventName: The original event name that was published (a copy of it, not the original pointer)</li>
<li>eventData: The original event data</li>
</ul>
<p>Note that this callback will be called from the background thread used for publishing. You should not perform any lengthy operations and you should avoid using large amounts of stack space during this callback. </p>

</div>
</div>
<a id="ae2a23fcaed89654f9c9f17adfdddb4bd" name="ae2a23fcaed89654f9c9f17adfdddb4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a23fcaed89654f9c9f17adfdddb4bd">&#9670;&#160;</a></span>withSpiFlash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> &amp; PublishQueueSpiFlashRK::withSpiFlash </td>
          <td>(</td>
          <td class="paramtype">SpiFlash *</td>          <td class="paramname"><span class="paramname"><em>spiFlash</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addrStart</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addrEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spiFlash</td><td>The SpiFlashRK object for the SPI NOR flash chip. </td></tr>
    <tr><td class="paramname">addrStart</td><td>Address to start at (typically 0). Must be sector aligned (multiple of 4096 bytes). </td></tr>
    <tr><td class="paramname">addrEnd</td><td>Address to end at (not inclusive). Must be sector aligned (multiple of 4096 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a>&amp; </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aa1882834270be9a7d25f4524618dc6ea" name="aa1882834270be9a7d25f4524618dc6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1882834270be9a7d25f4524618dc6ea">&#9670;&#160;</a></span>_instance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_spi_flash_r_k.html">PublishQueueSpiFlashRK</a> * PublishQueueSpiFlashRK::_instance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singleton instance of this class. </p>
<p>The object pointer to this class is stored here. It's NULL at system boot. </p>

</div>
</div>
<a id="a0d16202be4f2089df5ad4b256824360b" name="a0d16202be4f2089df5ad4b256824360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d16202be4f2089df5ad4b256824360b">&#9670;&#160;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os_mutex_recursive_t PublishQueueSpiFlashRK::mutex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to protect shared resources. </p>
<p>This is initialized in <a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a> so make sure you call the <a class="el" href="#a70e5c4ec556be575b3cba06af692dbf3" title="Perform setup operations; call this from global application setup()">setup()</a> method from the global application setup. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_publish_queue_spi_flash_r_k_8h_source.html">PublishQueueSpiFlashRK.h</a></li>
<li>src/<b>PublishQueueSpiFlashRK.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
